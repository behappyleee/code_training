package ch_01;

public class Clean_05 {
	
	// try-catch 문은 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤 섞는다.
	// 오류 처리도 한 작업이다. 오류를 처리하는 함수는 오류만 처리하여야 한다.
	// 중복은 모든 소프트웨어의 악의 근본이다.
	// 주석은 나쁜 코드를 보완하지 못한다. 확실히 코드만으로 의도를 설명하기 어려운 경우가 존재 
	// 어떤 주석은 필요하거나 유익, 정보를 제공하는 주석 (때로는 기본적인 정보를 주석으로 제공하면 편리)
	
	// 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메서드나 오버라이딩이 가능한 protected 메서드
	// 등 으로 만든 뒤 서브클래스에서 이런 메서드를 피룡에 맞게 구현해서 사용하도록 하는 방법을 디자인 패턴에서
	// Template Method Pattern 이라고 한다.
	
//	C++이 어려운 이유는 이 언어로 프로젝트를 하기 위해서는 OOP를 어느정도 이해해야만 하기 때문입니다. 저의 개인적인 경험으로는 클래스라는 것의 필요성을 이해하기까지 약 5년 걸렸던 것 같습니다. 그리고 상속에 익숙해지기 까지 또다시 몇년이 흘렀죠. 이게 프로젝트를 하면서 느끼는 것과 실제 공부만하는 것은 이렇게 시간차이가 많이 생깁니다. 왜냐하면 우리나라 거의 대부분의 개발회사에서 직원들이 공부하는 시간을 인정해주는 곳은 아예 없습니다. 실제로 일년만 일 하지 않고 공부만 한다면, 성실하게 공부하면 6년정도, 열심히 하면 8년정도, 최대한 노력하면 약 10년 이상까지도 현업 프로그래머를 따라잡을 수가 있습니다. 프로그래밍을 현업에서 실전 경험을 많이 하면 실력이 불쑥불쑥 늘 것이라는 것은 대단한 착각입니다. 책을 보고 공부하지 않으면 절대 실력이 늘어나질 않습니다. 예를 들어서 기원에 가면 평생 4급인 사람이 수두룩 합니다. 바둑 4급도 어느정도 책보고 공부해야만 그 정도까지 오릅니다. 하지만 1급이나 단이상이 되기 위해서는 정말 열심히 공부해야만 하는 것과 비슷합니다. 평생 기원에서 바둑만 둔다고 기량이 늘어나는 것은 결코 아니라는 사실을 명심해야만 합니다. 이야기가 삼천포로 빠졌네요. C++이 어려운 이유는 OOP를 어느정도 이해해야만 비로소 프로젝트 진향방향을 이해하기 때문입니다. 단순히 상속과 캡슐화가 별도의 성격이라고 외우고 별것 아니네 하면,  OOP가 점점 이상하게 꼬여들어갑니다. 예를 들어서 어떤 속성을 Private로 막을지 아니면 Public으로 공개할지에 대한 개념이 그냥 막 생각나는대로 하는게 아니기 때문입니다. 상속과정에서의 인터페이스를 생각해야만 합니다. 다시 이 인터페이스 설계가 무척이나 어려운 것은 클래스 의존성이 생겨나기 때문입니다. 이걸 피하기 위해서는 또 디자인 패턴을 공부해야만 합니다. 그러니까 저의 지금 수준으로 말씀드리자면, 저는 다시 캡슐화와 상속에 대한 고민을 점점 더 많이 하고 있습니다. 클래스가 일단 100개가 넘어가면 이것들끼리 복잡하게 얽히고 설킵니다. 자... 다시 처음으로 돌아와서, 일반적으로 (저는 자바 프로젝트는 잘 모르겠습니다.) C# 프로그래머의 OOP 이해도는 정말 바닥 수준입니다. 왜냐하면 툴 차원에서 다 만들어주니까요. 어떤 언어든지 고급이상으로 가려면 라이브러리를 분석해야만 합니다. 그런데 그 라이브러리가 단순히 프로시저만 줄줄이 따라가면 이해될 거라고 생각하면 천만의 말씀 만만의 콩떡입니다. 이 라이브러리가 모두 다 디자인 패턴이나 복합패턴으로 이루어져 있습니다. 대부분의 C#  프로그래머는 그냥 라이브러리가 지원해주는 구조를 그대로 사용합니다. 물론 그게 현명하겠죠. 하지만 그 라이브러리 구조를 이해하느냐 아니냐는 정말로 천지차이입니다. 다시 돌아와서 C++이 어렵다고 하는 것은 C++ 자체가 복합 언어라는 측면이 있지만 사실 MFC를 기본적으로 보면 이 구조자체가 어렵습니다. 구조도 어렵고 사용하기도 쉽지가 않습니다. 물론 C++이 Visual C++만 있는 것은 아니겠지만, 일단 그렇습니다. 왜 이렇게 사용하기 어렵게 해 놓았을까요? 그것은 프로젝트의 복잡성의 규모를 상당히 높게 잡았기 때문입니다. 프로젝트의 성능을 높이기 위해서는 메모리 버퍼링을 많이 해야만 합니다. (사실 소켓이나 시리얼 통신도 다 버퍼링과 관련이 있음.) 이렇게 버퍼링이 많아지면 프로젝트가 엄청나게 복잡하게 됩니다. 그러니까 MFC는 다른 C#이나 볼랜드 빌더와는 다르게 사용구조 자체가 상당히 어렵고, 그 이유는 기본적인 사용자의 베이스를 수준 이상으로 잡고 있기 때문입니다. 물론 MFC가 20년된 낡은 라이브러리라는 사실에는 저도 동감합니다. 하지만 그 구조에 사용된 옵저버패턴이나 브리지 패턴등(저는 스트레티지 패턴인줄 알았는데..) 이 사용되어 있고 이 구조를 어느정도 이해해야만 자신의 프로젝트에 적용하는데 어려움이 없습니다. 
//			C++을 하라는 이유가 그렇습니다. 다른 언어보다도 더 OOP에 대한 이해도를 많이 필요로하기 때문입니다. 일예로 STL이라는 라이브러리는 하나의 디자인 패턴을 정형화한 것입니다. 그렇다면 반대로 이 언어를 공부하다가 포기한다면 어떤 사단이 나는가... 저의 예상으로는 대부분의 프로그래머가 클래스 하나 제대로 만들 줄 모릅니다. 자... 제가 지나치게 객체지향에 대해 과장된 표현을 했다고 생각한다면, 고급 서적들을 보시면 리펙토링이라는 말이 항상, 꼭, 반드시 나옵니다. 이 리펙토링이 무엇을 의미하는지 디자인패턴을 모르면 이 책 자체가 이해가 되질 않습니다.  물론 앞의 삼분의 1 정도는 그냥 그냥 보실 수는 있습니다. 제가 잘난체를 하는게 아닙니다. 우리나라 소프트웨어 개발의 현실이 너무 암울하고 암담하여 드리는 말씀입니다. 
//			개발업체에서는 직원들이 연구하고 공부하는 시간을 거의 돈낭비, 시간낭비라고 생각합니다. 그래서 줄코딩, 하드코딩을 암묵적으로 강요합니다. 그 이유는 개발업체에 근무하는 고위임원이나 상급자가 소프트웨어 구조에 대한 이해가 거의 없기 때문입니다. 악순환이 벌어지는 것이죠. 내가 사수에게 이렇게 배웠듯이 후배들에게 똑같은 과정을 답습하게 합니다. 하나의 프로그래머를 정말 써먹을 수 있는 상태로 만들기 위해서는 최소한 2,3년 정도의 시간이 걸립니다. 그런데 이제 막 들어온 신입에게 유지보수를 맡기는 일이 허다합니다. 프로그래밍을 코드의 조합과 연결로만 이해하는 DOS 시절의 임원들이 아직도 많이 있기 때문입니다. 또한 대부분의 소프트웨어 개발회사들이 인력을 스스로 가꾸고 개발할 노력을 거의 안합니다. 오늘은 여기까지 하겠습니다. 정말 쓰려면 책한권 나오겠습니다.
//	
	
//	고급이나 특급으로 올라갈수록 성능에 대한 아쉬움이 많습니다. C#이나 자바는 성능좋은 라이브러리가 많지만 실제 UI에서 overhead가 많이 발생할 수밖에는 없습니다. 컴파일러형 언어와 반인터프리터 언어의 차이는 위로 갈수록 극명하게 갈립니다. 자바가 깊이가 있다고 하는데, 그것은 객체지향을 목적으로 설계되어졌다는 것을 의미하는 것 같습니다. 하지만 결국 자바나 C# 모두 C++을 다듬은 언어에 지나지 않습니다. 컴파일러형 언어에 대한 갈증이 없다면 어셈블리나 기계어는 아예 생각도 안할지도 모르겠습니다. 어셈블리를 공부해야만 하는 이유는 CPU구조를 이해하는데 정말 많은 도움이 될 뿐만이 아니라 악질적인 버그에 대한 디버깅에 아직도 요긴하게 사용하기 때문입니다. 그리고 한번쯤은 기계어로 코딩을 해본 경험이 있어야만 합니다. 그래야만 CPU의 진정한 overhead가 어떤 것인지를 느끼게 됩니다. 물론 어셈블리만으로도 가능하지만요. 
//	제가 생각하기에 기계어, 어셈블리, C++까지 정복해야만 특급 이상으로 올라갈 수가 있을 것 같습니다. OverHead의 문제는 곧 성능의 문제이고, 각 고유의 프로젝트마다 정밀하게 최적화된 코드가 없다면 성능은 물건너 갑니다. 물론 유지보수의 문제인 객체지향에 대한 소프트웨어 구조에 대한 깊이는 별도로 계속해서 공부해야만 하겠죠. 
//	일단 우리나라 프로젝트의 90%이상이 납품용 프로젝트입니다. 이런 상황에서 연구하고 개발하는 소프트웨어 프로젝트는 정말 희귀합니다. 납품용 프로젝트는 단가와 기간이 생명입니다. 따라서 이런 관점에 맞는 언어가 있겠죠. 하지만 게임이나 유틸개발에 C#이나 자바로 개발하는 것은 거의 불가능합니다. 물론 개발할 수는 있습니다. 흉내는 낼 수가 있다는 것이죠. 이 언어로 포토샵이나 3D Max나 워드 프로그램 등을 개발하지는 못합니다. 
//	젊은 후배님들이 좀 더 큰 꿈을 키우시길 바랍니다. 납품용 프로젝트는 실력만 된다면 얼마든지 어디든지 30대 중반 이후에도 참여할 수가 있습니다. 그러나 20대부터 그런 대중적인 언어로 납품용 프로젝트에 최적화된 스킬만을 갈고 닦는다면 나중에는 아예 우물만 개구리가 되어 버립니다. 
//	20대에는 먼저 C++에 도전해보시고 그 이후에 잘 안되면 30대에 자바나 C#을 해도 결코 늦지를 않습니다. 
//	저처럼 거꾸로 올라가면 정말 많은 시간을 허비합니다. 처음에 웹프로그래밍으로 시작했는데 너무 쉬워서 미래가 불안했습니다. 그 다음으로 볼랜드계열의 컴포넌트 기반 개발을 하였죠. 하지만 이것도 쉬웠습니다. 그래서 C++을 하니까 이제 좀 뭐가 보이기 시작했습니다. 이렇게 수십년을 낭비했다는 생각이 많이 듭니다. 프로그래머는 치열한 경쟁사회에서도 한가운데에 있습니다. 쉬운 언어를 공부하면 반드시 그 댓가가 따라옵니다. 그 이유는 언어가 쉽다는 것은 일단 특정 목적에 따라 개발되었다는 것을 의미하는 것이고, 그 목적이 다른 수단으로 대체되거나 시대가 바뀌어 더 포괄적인 형태의 다른 언어가 탄생되면 순식간에 도태되기 때문입니다. 가장 사라지지 않을 것 같은 언어 1위는 언제나 항상 C++이었습니다. 그리고 지금도 계속해서 업버전되고 있는 언어입니다.
	
	
	
	
}
